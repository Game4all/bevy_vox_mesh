use anyhow::{anyhow, Error};
use bevy::asset::{AssetLoader, LoadContext, LoadedAsset};
use block_mesh::QuadCoordinateConfig;

use crate::mate_data::VoxMateData;

/// An asset loader capable of loading models in `.vox` files as usable [`bevy::render::mesh::Mesh`]es.
///
/// The meshes generated by this asset loader only use standard [`bevy::render::mesh::Mesh`] attributes for easier compatibility with shaders.
/// You can load multiple models from the same `.vox` file by appending `#model{no}` to the asset loading path, where `{no}` corresponds to the model index in the file.
pub struct VoxLoader {
    /// Whether to flip the UVs vertically when meshing the models.
    /// You may want to change this to false if you aren't using Vulkan as a graphical backend for bevy , else this should default to true.
    pub(crate) config: QuadCoordinateConfig,
    pub(crate) v_flip_face: bool,
}

impl AssetLoader for VoxLoader {
    fn load<'a>(
        &'a self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> bevy::utils::BoxedFuture<'a, Result<(), Error>> {
        Box::pin(async move {
            self.process_vox_file(bytes, load_context).await?;
            Ok(())
        })
    }

    fn extensions(&self) -> &[&str] {
        &["vox"]
    }
}

impl VoxLoader {
    async fn process_vox_file<'a, 'b>(
        &self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext<'b>,
    ) -> Result<(), Error> {
        let file = match dot_vox::load_bytes(bytes) {
            Ok(data) => data,
            Err(error) => return Err(anyhow!(error)),
        };

        let palette: Vec<[f32; 4]> = file
            .palette
            .iter()
            .map(|color| {
                let color_rgba: [u8; 4] = color.into();
                color_rgba.map(|byte| byte as f32 / u8::MAX as f32)
            })
            .collect();

        for (index, model) in file.models.iter().enumerate() {
            let (shape, buffer) = crate::voxel::load_from_model(model);
            let mesh =
                crate::mesh::mesh_model(shape, &buffer, &palette, &self.config, self.v_flip_face);
            match index {
                0 => {
                    load_context.set_default_asset(LoadedAsset::new(mesh.clone()));
                }
                _ => {
                    load_context.set_labeled_asset(
                        &format!("model{}", index),
                        LoadedAsset::new(mesh.clone()),
                    );
                }
            }
        }
        load_context.set_labeled_asset(
            &format!("mate_data"),
            LoadedAsset::new(VoxMateData {
                scenes: file.scenes,
                layers: file.layers,
            }),
        );

        Ok(())
    }
}
