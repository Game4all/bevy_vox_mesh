
use anyhow::anyhow;
use bevy::{
    asset::{io::Reader, AssetLoader, AsyncReadExt, LoadContext, Handle},
    render::{texture::Image, render_resource::{Extent3d, TextureDimension, TextureFormat}, color::Color},
    utils::{BoxedFuture, hashbrown::HashMap}, pbr::StandardMaterial,
};
use serde::{Deserialize, Serialize};
use thiserror::Error;

use crate::voxel_scene::{self, VoxelScene, LayerInfo, VoxelModel};

/// An asset loader capable of loading models in `.vox` files as usable [`bevy::render::mesh::Mesh`]es.
///
/// The meshes generated by this asset loader only use standard [`bevy::render::mesh::Mesh`] attributes for easier compatibility with shaders.
/// You can load multiple models from the same `.vox` file by appending `#{name}` to the asset loading path, where `{name}` corresponds to the object's name in the Magical Voxel world editor.
/// You can load unnamed models by appending `#model{no}` to the asset loading path, where `{no}` corresponds to the model index in the file. Note that this index is subject to change if you delete models in the Magica Voxel file.
pub struct VoxSceneLoader;

#[derive(Serialize, Deserialize)]
pub struct VoxLoaderSettings {
    /// Multiplier for emissive strength. Defaults to 2.0.
    pub emission_strength: f32,
    /// Defaults to `true` to more accurately reflect the colours in Magica Voxel.
    pub uses_srgb: bool,
    /// Magica Voxel doesn't let you adjust the roughness for the default "diffuse" block type, so it can be adjusted with htis setting. Defaults to 0.5.
    pub diffuse_roughness: f32,
}

impl Default for VoxLoaderSettings {
    fn default() -> Self {
        Self { emission_strength: 2.0, uses_srgb: true, diffuse_roughness: 0.5 }
    }
}

#[derive(Error, Debug)]
pub enum VoxLoaderError {
    #[error(transparent)]
    InvalidAsset(#[from] anyhow::Error),
}

impl AssetLoader for VoxSceneLoader {
    type Asset = VoxelScene;
    type Settings = VoxLoaderSettings;
    type Error = VoxLoaderError;
    
    fn load<'a>(
        &'a self,
        reader: &'a mut Reader,
        _settings: &'a Self::Settings,
        load_context: &'a mut LoadContext,
    ) -> BoxedFuture<'a, Result<Self::Asset, VoxLoaderError>> {
        Box::pin(async move {
            let mut bytes = Vec::new();
            reader
            .read_to_end(&mut bytes)
            .await
            .map_err(|e| VoxLoaderError::InvalidAsset(anyhow!(e)))?;
            Ok(self.process_vox_file(&bytes, load_context, _settings)?)
        })
    }
    
    fn extensions(&self) -> &[&str] {
        &["vox"]
    }
}

impl VoxSceneLoader {
    fn process_vox_file<'a>(
        &self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
        settings: &'a VoxLoaderSettings,
    ) -> Result<VoxelScene, VoxLoaderError> {
        let file = match dot_vox::load_bytes(bytes) {
            Ok(data) => data,
            Err(error) => return Err(VoxLoaderError::InvalidAsset(anyhow!(error))),
        };
        
        // Color
        let color_data: Vec<u8> = file.palette.iter().flat_map(|c| {
            let rgba: [u8; 4] = c.into(); 
            rgba
        }).collect();
        let color_image = Image::new(Extent3d { width: 16, height: 16, depth_or_array_layers: 1 }, TextureDimension::D2, color_data, if settings.uses_srgb { TextureFormat::Rgba8UnormSrgb } else { TextureFormat::Rgba8Unorm });
        let color_handle = load_context.add_labeled_asset("material_base_color".to_string(), color_image);
        
        // Emissive
        let emissive_data: Vec<Option<f32>> = file.materials.iter().map(|m| {
            if let Some(emission) = m.emission() {
                if let Some(radiance) = m.radiant_flux() {
                    Some(emission * (radiance + 1.0))
                } else {
                    Some(emission)
                }
            } else {
                None
            }
        }).collect();
        let has_emissive = !emissive_data.iter().flatten().cloned().collect::<Vec<f32>>().is_empty();
        let emissive_texture: Option<Handle<Image>> = if has_emissive {
            let emissive_raw: Vec<u8> = emissive_data.iter().zip(file.palette.iter()).flat_map(|(emission, color)| {
                if let Some(value) = emission {
                    let rgba: [u8; 4] = color.into();
                    let output: Vec<u8> = rgba.iter().flat_map(|b| ((*b as f32 / u8::MAX as f32) * value).to_le_bytes() ).collect();
                    output
                } else {
                    let rgba: [f32; 4] = [0.0, 0.0, 0.0, 0.0];
                    let output: Vec<u8> = rgba.iter().flat_map(|b| b.to_le_bytes()).collect();
                    output
                }
            }).collect();
            let emissive_image = Image::new(Extent3d { width: 16, height: 16, depth_or_array_layers: 1 }, TextureDimension::D2, emissive_raw, TextureFormat::Rgba32Float);
            let emissive_handle = load_context.add_labeled_asset("material_emission".to_string(), emissive_image);
            Some(emissive_handle)
        } else {
            None
        };
        
        // Roughness/ Metalness
        let roughness: Vec<f32> = file.materials.iter().map(|m| {
            if m.material_type() == Some("_diffuse") { return settings.diffuse_roughness };
            m.roughness().unwrap_or(0.0)
        }).collect();
        let max_roughness = roughness.iter().cloned().max_by(|a, b| a.partial_cmp(b).expect("tried to compare NaN")).unwrap();
        let has_varying_roughness = max_roughness - roughness.iter().cloned().min_by(|a, b| a.partial_cmp(b).expect("tried to compare NaN")).unwrap() > 0.001;
        
        let metalness: Vec<f32> = file.materials.iter().map(|m| {
            m.metalness().unwrap_or(0.0)
        }).collect();
        let max_metalness = metalness.iter().cloned().max_by(|a, b| a.partial_cmp(b).expect("tried to compare NaN")).unwrap();
        let has_varying_metalness = max_metalness - metalness.iter().cloned().min_by(|a, b| a.partial_cmp(b).expect("tried to compare NaN")).unwrap() > 0.001;
        let has_metallic_roughness = has_varying_roughness || has_varying_metalness;
        let metallic_roughness_texture: Option<Handle<Image>> = if has_metallic_roughness {
            let raw: Vec<u8> = roughness.iter().zip(metalness.iter()).flat_map(|(rough, metal)| {
                let output: Vec<u8> = [0.0, *rough, *metal, 0.0].iter().flat_map(|b| ((b * u16::MAX as f32) as u16).to_le_bytes()).collect();
                output
            }).collect();
            let image = Image::new(Extent3d { width: 16, height: 16, depth_or_array_layers: 1 }, TextureDimension::D2, raw, TextureFormat::Rgba16Unorm);
            let handle = load_context.add_labeled_asset("material_metallic_roughness".to_string(), image);
            Some(handle)
        } else {
            None
        };
        
        // Specular transmission
        let transparency_data: Vec<Option<f32>> = file.materials.iter().map(|m| m.opacity()).collect();
        let has_transparency = !transparency_data.iter().flatten().cloned().collect::<Vec<f32>>().is_empty();
        let specular_transmission_texture: Option<Handle<Image>> = if has_transparency {
            let raw: Vec<u8> = transparency_data.iter().flat_map(|t| {
                ((t.unwrap_or(0.0) * u16::MAX as f32) as u16).to_le_bytes()
            }).collect();
            let image = Image::new(Extent3d { width: 16, height: 16, depth_or_array_layers: 1 }, TextureDimension::D2, raw, TextureFormat::R16Unorm);
            let handle = load_context.add_labeled_asset("material_specular_transmission".to_string(), image);
            Some(handle)
        } else {
            None
        };
        let iors: Vec<f32> = file.materials.iter().map(|m| m.refractive_index() ).flatten().collect();
        let average_ior = if iors.len() > 0 { 1.0 + (iors.iter().cloned().reduce(|acc, e| acc + e).unwrap_or(0.0) / iors.len() as f32) } else { 0.0 };
        let translucent_voxel_indices: Vec<u8> = file.materials.iter().enumerate().filter_map(|(i, val)| if val.opacity().is_some() { Some(i as u8) } else { None }).collect();
        
        // Material
        let translucent_material = StandardMaterial {
            base_color_texture: Some(color_handle.clone()),
            emissive: if has_emissive { Color::WHITE * settings.emission_strength } else { Color::BLACK },
            emissive_texture: emissive_texture.clone(),
            perceptual_roughness: if has_metallic_roughness { 1.0 } else { max_roughness },
            metallic: if has_metallic_roughness { 1.0 } else { max_metalness },
            metallic_roughness_texture: metallic_roughness_texture.clone(),
            specular_transmission: if has_transparency { 1.0 } else { 0.0 },
            specular_transmission_texture: specular_transmission_texture,
            ior: average_ior,
            thickness: if has_transparency { 4.0 } else { 0.0 },
            ..Default::default()
        };
        let opaque_material = StandardMaterial {
            base_color_texture: Some(color_handle),
            emissive: if has_emissive { Color::WHITE * settings.emission_strength } else { Color::BLACK },
            emissive_texture,
            perceptual_roughness: if has_metallic_roughness { 1.0 } else { max_roughness },
            metallic: if has_metallic_roughness { 1.0 } else { max_metalness },
            metallic_roughness_texture,
            ..Default::default()
        };
        let translucent_material_handle = load_context.add_labeled_asset("material_translucent".to_string(), translucent_material);
        let opaque_material_handle = load_context.add_labeled_asset("material_opaque".to_string(), opaque_material);

        // Scene graph

        let mut shape_names = HashMap::new();
        let root = voxel_scene::parse_xform_node(&file.scenes, &file.scenes[0], &mut shape_names);
        //println!("graph {:#?}", root);
        let mut scene = VoxelScene { 
            root, 
            models: HashMap::new(),
            layers: file.layers.iter().map(|layer| LayerInfo { name: layer.name(), is_hidden: layer.hidden() }).collect(), 
        };
        
        // Models
        for (id, name) in shape_names {
            let Some(model) = file.models.get(id as usize) else { continue };
            let (shape, buffer, has_translucent_voxels) = crate::voxel::load_from_model(model, &translucent_voxel_indices);
            let mesh = crate::mesh::mesh_model(shape, &buffer);
            let mesh_handle = load_context.add_labeled_asset(name.clone(), mesh);
            scene.models.insert(name, VoxelModel { 
                mesh: mesh_handle, 
                material: if has_translucent_voxels { translucent_material_handle.clone() } else { opaque_material_handle.clone() },
            });
        }
        Ok(scene)
    }
}
