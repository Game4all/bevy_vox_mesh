
use anyhow::{anyhow, Context};
use bevy::{
    asset::{io::Reader, AssetLoader, AsyncReadExt, LoadContext},
    render::{mesh::Mesh, texture::Image, render_resource::{Extent3d, TextureDimension, TextureFormat}},
    utils::BoxedFuture, pbr::StandardMaterial,
};
use block_mesh::QuadCoordinateConfig;
use dot_vox::SceneNode;
use thiserror::Error;

/// An asset loader capable of loading models in `.vox` files as usable [`bevy::render::mesh::Mesh`]es.
///
/// The meshes generated by this asset loader only use standard [`bevy::render::mesh::Mesh`] attributes for easier compatibility with shaders.
/// You can load multiple models from the same `.vox` file by appending `#{name}` to the asset loading path, where `{name}` corresponds to the object's name in the Magical Voxel world editor.
/// You can load unnamed models by appending `#model{no}` to the asset loading path, where `{no}` corresponds to the model index in the file. Note that this index is subject to change if you delete models in the Magica Voxel file.
pub struct VoxLoader {
    /// Whether to flip the UVs vertically when meshing the models.
    /// You may want to change this to false if you aren't using Vulkan as a graphical backend for bevy , else this should default to true.
    pub(crate) config: QuadCoordinateConfig,
    pub(crate) v_flip_face: bool,
}

#[derive(Error, Debug)]
pub enum VoxLoaderError {
    #[error(transparent)]
    InvalidAsset(#[from] anyhow::Error),
}

impl AssetLoader for VoxLoader {
    type Asset = Mesh;
    type Settings = ();
    type Error = VoxLoaderError;
    
    fn load<'a>(
        &'a self,
        reader: &'a mut Reader,
        _settings: &'a Self::Settings,
        load_context: &'a mut LoadContext,
    ) -> BoxedFuture<'a, Result<Self::Asset, VoxLoaderError>> {
        Box::pin(async move {
            let mut bytes = Vec::new();
            reader
            .read_to_end(&mut bytes)
            .await
            .map_err(|e| VoxLoaderError::InvalidAsset(anyhow!(e)))?;
            Ok(self.process_vox_file(&bytes, load_context)?)
        })
    }
    
    fn extensions(&self) -> &[&str] {
        &["vox"]
    }
}

impl VoxLoader {
    fn process_vox_file<'a>(
        &self,
        bytes: &'a [u8],
        load_context: &'a mut LoadContext,
    ) -> Result<Mesh, VoxLoaderError> {
        let file = match dot_vox::load_bytes(bytes) {
            Ok(data) => data,
            Err(error) => return Err(VoxLoaderError::InvalidAsset(anyhow!(error))),
        };
        
        let color_data: Vec<u8> = file.palette.iter().flat_map(|c| {
            let rgba: [u8; 4] = c.into(); 
            rgba
        }).collect();
        let color_image = Image::new(Extent3d { width: 256, height: 1, depth_or_array_layers: 1 }, TextureDimension::D2, color_data, TextureFormat::Rgba8Unorm);
        let color_handle = load_context.add_labeled_asset("base_color".to_string(), color_image);
        let material = StandardMaterial {
            base_color_texture: Some(color_handle),
            ..Default::default()
        };
        load_context.add_labeled_asset("material".to_string(), material);
        
        let named_models = parse_scene_graph(&file.scenes, &file.scenes[0], &None);
        let mut default_mesh: Option<Mesh> = None;
        for NamedModel { name, id } in named_models {
            let Some(model) = file.models.get(id as usize) else { continue };
            let (shape, buffer) = crate::voxel::load_from_model(model);
            let mesh =
            crate::mesh::mesh_model(shape, &buffer,  &self.config);
            if id == 0 {
                default_mesh = Some(mesh.clone());
            }
            load_context.add_labeled_asset(name, mesh);
        }           
        Ok(default_mesh.context("No models found in vox file")?)
    }
}

struct NamedModel {
    name: String,
    id: u32,
}

fn parse_scene_graph(
    graph: &Vec<SceneNode>,
    node: &SceneNode,
    node_name: &Option<String>,
) -> Vec<NamedModel> {
    match node {
        SceneNode::Transform { attributes, frames: _, child, layer_id: _ } => {
            let handle: Option<String> = match (node_name, &attributes.get("_name")) {
                (None, None) => None,
                (None, Some(name)) => Some(name.to_string()),
                (Some(name), None) => Some(name.to_string()),
                (Some(a), Some(b)) => Some(format!("{a}-{b}")),
            };
            parse_scene_graph(graph, &graph[*child as usize], &handle)
        }
        SceneNode::Group { attributes: _, children } => {
            children.iter().flat_map(|child| {
                parse_scene_graph(graph, &graph[*child as usize], node_name)
            }).collect()
        }
        SceneNode::Shape { attributes: _, models } => {
            models.iter().map(|model| {
                let handle = if let Some(name) = node_name { name.to_owned() } else { format!("model{}", model.model_id) };
                NamedModel { name: handle, id: model.model_id }
            }).collect()
        }
    }
}